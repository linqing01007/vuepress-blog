<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>作用域 | 林晴的博客</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="林晴的个人博客">
    <meta name="author" content="林晴">
    
    <link rel="preload" href="/vuepress-blog/assets/css/0.styles.a53365af.css" as="style"><link rel="preload" href="/vuepress-blog/assets/js/app.ad5aaf85.js" as="script"><link rel="preload" href="/vuepress-blog/assets/js/2.b6e7c728.js" as="script"><link rel="preload" href="/vuepress-blog/assets/js/13.fe79309d.js" as="script"><link rel="prefetch" href="/vuepress-blog/assets/js/10.ed486a11.js"><link rel="prefetch" href="/vuepress-blog/assets/js/11.bc20b250.js"><link rel="prefetch" href="/vuepress-blog/assets/js/12.50b067f3.js"><link rel="prefetch" href="/vuepress-blog/assets/js/14.209bdc65.js"><link rel="prefetch" href="/vuepress-blog/assets/js/15.ccac7c65.js"><link rel="prefetch" href="/vuepress-blog/assets/js/16.c89c7de1.js"><link rel="prefetch" href="/vuepress-blog/assets/js/17.08eabaaa.js"><link rel="prefetch" href="/vuepress-blog/assets/js/18.c55f580b.js"><link rel="prefetch" href="/vuepress-blog/assets/js/19.2f27e27a.js"><link rel="prefetch" href="/vuepress-blog/assets/js/20.a0e490d8.js"><link rel="prefetch" href="/vuepress-blog/assets/js/21.f5ad3465.js"><link rel="prefetch" href="/vuepress-blog/assets/js/22.fc656f29.js"><link rel="prefetch" href="/vuepress-blog/assets/js/23.966ca396.js"><link rel="prefetch" href="/vuepress-blog/assets/js/24.83ab36bc.js"><link rel="prefetch" href="/vuepress-blog/assets/js/25.4a3548a8.js"><link rel="prefetch" href="/vuepress-blog/assets/js/26.2d9198f6.js"><link rel="prefetch" href="/vuepress-blog/assets/js/27.a4198cfa.js"><link rel="prefetch" href="/vuepress-blog/assets/js/28.365fc50a.js"><link rel="prefetch" href="/vuepress-blog/assets/js/29.0188b855.js"><link rel="prefetch" href="/vuepress-blog/assets/js/3.bee68f82.js"><link rel="prefetch" href="/vuepress-blog/assets/js/30.e15a49d1.js"><link rel="prefetch" href="/vuepress-blog/assets/js/31.e00a8b75.js"><link rel="prefetch" href="/vuepress-blog/assets/js/32.50afa64d.js"><link rel="prefetch" href="/vuepress-blog/assets/js/33.09e0cc22.js"><link rel="prefetch" href="/vuepress-blog/assets/js/34.aca89d89.js"><link rel="prefetch" href="/vuepress-blog/assets/js/35.0047cafa.js"><link rel="prefetch" href="/vuepress-blog/assets/js/36.bc263f17.js"><link rel="prefetch" href="/vuepress-blog/assets/js/37.88b11810.js"><link rel="prefetch" href="/vuepress-blog/assets/js/38.52233360.js"><link rel="prefetch" href="/vuepress-blog/assets/js/39.98cd31b3.js"><link rel="prefetch" href="/vuepress-blog/assets/js/4.dec834b8.js"><link rel="prefetch" href="/vuepress-blog/assets/js/40.dc4ff538.js"><link rel="prefetch" href="/vuepress-blog/assets/js/41.125d2997.js"><link rel="prefetch" href="/vuepress-blog/assets/js/5.6f94c648.js"><link rel="prefetch" href="/vuepress-blog/assets/js/6.600bc016.js"><link rel="prefetch" href="/vuepress-blog/assets/js/7.d84fc58f.js"><link rel="prefetch" href="/vuepress-blog/assets/js/8.90f7891a.js"><link rel="prefetch" href="/vuepress-blog/assets/js/9.5bbded7f.js">
    <link rel="stylesheet" href="/vuepress-blog/assets/css/0.styles.a53365af.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/vuepress-blog/" class="home-link router-link-active"><!----> <span class="site-name">林晴的博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>vue3</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>javascript专题</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vuepress-blog/javascript专题/Reflect.ownKeys与Object.keys的区别.html" class="sidebar-link">Reflect.ownKeys与Object.keys的区别</a></li><li><a href="/vuepress-blog/javascript专题/class继承与es5继承的区别.html" class="sidebar-link">class继承与es5继承的区别</a></li><li><a href="/vuepress-blog/javascript专题/你不知道的js.html" class="active sidebar-link">你不知道的js</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vuepress-blog/javascript专题/你不知道的js.html#作用域" class="sidebar-link">作用域</a></li><li class="sidebar-sub-header"><a href="/vuepress-blog/javascript专题/你不知道的js.html#对象" class="sidebar-link">对象</a></li><li class="sidebar-sub-header"><a href="/vuepress-blog/javascript专题/你不知道的js.html#异步" class="sidebar-link">异步</a></li><li class="sidebar-sub-header"><a href="/vuepress-blog/javascript专题/你不知道的js.html#强制类型转换" class="sidebar-link">强制类型转换</a></li></ul></li><li><a href="/vuepress-blog/javascript专题/基本数据类型.html" class="sidebar-link">基本数据类型</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>css</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>dom</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>前端笔记</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>综合实践</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>部署</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="作用域"><a href="#作用域" class="header-anchor">#</a> 作用域</h2> <p>作用域可以理解为一组定义变量如何查询与取值的规则，在js中，有LHS(取得目标的源，一般是赋值操作，如果没有找到且不在“strict'模式下，则会隐含的创建变量)和RHS(取得目标的值)两种查询规则；
对于表达式var a = 2，编译器对先查看作用域是否已经声明了变量a，如果没有则让作用域创建变量a，然后引擎执行代码时首先让作用域查看在当前作用域是否有变量a，没有则会沿着作用域链一直查询，直到
有或者报出一个错误。</p> <h3 id="词法作用域"><a href="#词法作用域" class="header-anchor">#</a> 词法作用域</h3> <p>词法作用域是基于在编写代码时 变量和函数在何处编写 而决定的，在词法分析阶段就可以知道所有标识符在哪里和如何声明的，并可预期在执行期改如何查询这些标识符。</p> <h3 id="提升"><a href="#提升" class="header-anchor">#</a> 提升</h3> <p>使用var关键字声明的变量和函数声明会存在 “提升” 现象，即无论声明的代码位置在哪里，对应的变量/函数在对应的作用域内任意位置均可访问。使用let, const关键字声明变量不会导致“提升”
函数声明会优先于变量声明。
对于语句var a = 2，javascript引擎会将var a 和 a = 2 看做是两个语句，第一个发生在编译期，第二个发生在执行阶段。
函数声明会被提升，但是函数表达式(function 关键字在语句中不在开头)不会被提升</p> <h3 id="作用域闭包"><a href="#作用域闭包" class="header-anchor">#</a> 作用域闭包</h3> <p>作用域闭包是指函数在声明时的作用域范围外（词法作用域）进行调用，依然持有原作用域的引用；
闭包的两个必要条件： 1.一个被调用的外部包装函数，用来创建外部作用域；2.该包装函数必须返回至少一个内部函数的引用，这个函数才拥有包装函数内部作用域的闭包</p> <h3 id="this对象"><a href="#this对象" class="header-anchor">#</a> this对象</h3> <p>this不是函数的自引用，也不是函数的词法作用域的引用，this是由函数是如何调用（函数调用栈）决定的。
this的绑定规则（按照优先级顺序）：
1是否有new调用，有则绑定到new 返回的对象
2是否显示绑定（apply， bind， call），有则为传入显示绑定的对象(显示传入null和undefined作为绑定对象会被忽略，实际应用的是默认绑定原则)
3通过持有调用的环境对象调用，绑定到那个环境对象
4 默认：strict mode 下是undefined， 否则是全局对象</p> <p>当一个函数被作为构造器调用（new 调用）时，会发生的事情：
1凭空创建一个全新的对象
2 这个新构建的对象会被接入原型链 newObj = Object.create(func.prototype)
3这个新构建的对象会被设置为函数调用的this（func.apply(newObj, arguments))
4除非函数返回一个他自己的其他对象，否则返回这个新创建的对象</p> <p>es6中的箭头函数是词法this，即在词法分析阶段就会知道this指向的对象：箭头函数在定义时执行器上下文的this指向（不具有块级作用域），即会取当前的函数的作用域链上的this，忽略块级作用域中的this。 剪头函数的this不会被其他所覆盖</p> <p>bind()函数创建了一个新的绑定函数，绑定函数包装了原函数对象，调用绑定函数会导致执行包装函数，调用绑定函数时，会指定该函数的this值为调用bind()函数时的第一个参数，参数列表为调用bind()函数的其他参数加上通过函数调用绑定函数传入的参数列表（即fB = f.bind(thisArg, arg1, arg2, arg3...),调用fB时，arg1, arg2, arg3会成为fB的初始参数列表</p> <p>bind函数的其中一种实现：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">bind</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">oThis</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span> <span class="token operator">!==</span> <span class="token string">&quot;function&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//这里的this指向调用bind的函数，如foo.bind(),则为foo</span>
        <span class="token keyword">throw</span> <span class="token function">TypeError</span><span class="token punctuation">(</span><span class="token string">&quot;not a function&quot;</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">let</span> fToBind <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">,</span><span class="token function-variable function">fNOP</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        curri <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function-variable function">fBound</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">//oThis指向传入bind的对象</span>
            <span class="token comment">//这里的this指向返回的绑定方法调用时的this绑定，一般为全局对象</span>
            <span class="token comment">//如f = foo.bind(), f.call({a: 1}), 则这里的this为{a: 1}</span>
            <span class="token comment">//但是，设计意图是为了让new绑定覆盖bind绑定，</span>
            <span class="token comment">//f = foo.bind(),F = new f(),此时这里的this指向对象F</span>
            <span class="token comment">//此时 this instanceof fNOP === true</span>
            <span class="token keyword">return</span> fToBind<span class="token punctuation">.</span><span class="token function">allpy</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token keyword">instanceof</span> <span class="token class-name">fNOP</span> <span class="token operator">&amp;&amp;</span> oThis <span class="token operator">?</span> 
            <span class="token keyword">this</span> <span class="token operator">:</span> oThis <span class="token operator">||</span> window<span class="token punctuation">,</span> curri<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>
                arguments<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
    fNOP<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
    fBound<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">fNOP</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 给绑定函数接入原型链</span>
    <span class="token keyword">return</span> fBound    <span class="token comment">//bind只是返回一个绑定后的方法</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="对象"><a href="#对象" class="header-anchor">#</a> 对象</h2> <h3 id="原型与原型链"><a href="#原型与原型链" class="header-anchor">#</a> 原型与原型链</h3> <p>许多开发者认为null是一个对象源于typeof null == object这样一个语言bug，实际上null的类型是null。（原理：不同的对象在底层都表示为二进制，在JavaScript中二进制前三位都为0的话会被判断为object类型，null的二进制表示全是0，所以执行typeof时会返回“object“。</p> <p>对象的[[put]]操作行为，myObject.foo = &quot;a&quot;, 如果将要设置的属性存在：</p> <ol><li>这个属性是访问器描述符吗？如果是，而且是setter，那么调用setter</li> <li>这个属性是writable为false的数据描述符吗？如果在，在非strict mode 下无声的失败，在strict mode 下抛出TypeError</li> <li>否则，像平时一样设置既存的值。
如果设置的属性不在对象，但是存在于myObject的[[prototype]]链的更高层时：</li> <li>如果一个普通名为foo的数据属性在[[prototype]]的更高层被找到， 而且没有被标记为只读，那么一个名为foo的属性将会被直接添加到myObject上，形成一个遮蔽属性。</li> <li>如果一个foo在[[prototype]]的更高层被找到，而且被设置为只读，那么设置既存属性和创建遮蔽属性都是不允许的</li> <li>如果一个foo在[[prototype]]的更高层被找到，而且是一个setter，那么setter总是会被调用，在myObject上不会创建遮蔽属性。</li></ol> <h3 id="继承"><a href="#继承" class="header-anchor">#</a> 继承</h3> <p>js中没有实质的“类”的概念，有的只是对象，js中不能创建一个“类”，创建的是一个个对象。</p> <h3 id="原型"><a href="#原型" class="header-anchor">#</a> 原型</h3> <p>a instanceof Foo 表示在a的整个[[prototype]]链中，有没有出现被Foo.prototype所指向的对象</p> <h2 id="异步"><a href="#异步" class="header-anchor">#</a> 异步</h2> <p>js中的异步通过事件轮询来实现，每当有一个代码块要执行时就会往 引擎 中添加一个事件（类似一个事件堆栈），引擎执行时会从堆栈中把事件一个一个拿出来执行，直到事件全部执行完成。
而类似异步的事件（如setTimeout）则会把事件添加到当前上下文中所有事件的末尾，这样就形成了“异步”。</p> <h3 id="回调"><a href="#回调" class="header-anchor">#</a> 回调</h3> <p>异步编程时过多使用回调会陷入“回调地狱”，容易使代码变得难以理解和维护(如果修改了某一个回调，可能上下层的回调都要跟着改)，重要的是，如果把你的回调函数传给第三方库，如axios等，你无法保证你的回调函数一定会被调用或者只调用一次，再者，如果回调函数失败了，无法进行重试；</p> <p>axios不支持finally的解决方法：
在Promise的原型链上添加finally实现</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token class-name">Promise</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">finally</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">let</span> <span class="token constant">P</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>constructor<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>
		<span class="token parameter">value</span> <span class="token operator">=&gt;</span> <span class="token constant">P</span><span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> value<span class="token punctuation">)</span><span class="token punctuation">,</span>
		<span class="token parameter">reason</span> <span class="token operator">=&gt;</span> <span class="token constant">P</span><span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token keyword">throw</span> reason<span class="token punctuation">}</span><span class="token punctuation">)</span>
		<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="强制类型转换"><a href="#强制类型转换" class="header-anchor">#</a> 强制类型转换</h2> <h3 id="值类型转换"><a href="#值类型转换" class="header-anchor">#</a> 值类型转换</h3> <p><code>toString()</code>，负责处理非字符串类型到字符串类型的强制类型转换；
基本类型的转化规则：null返回“null”，undefined返回“undefined”，数字遵循通用化规则，极大数和极小数使用指数形式
对于普通对象，除非自定义对象，否则返回内部属性[[class]]的值（&quot;[object array']&quot;)</p> <p><code>JSON.stringify()</code>，对大多数简单值，结果与toString基本相同
不安全的JSON值：undefined, function, symbol和包含循环引用的对象， JSON.stringify()操作在遇到不安全的JSON值会忽略，在数组中遇到时会用null占位，包含循环引用对象是抛出错误
如果对象自定义了toJSON方法，JSON化时会首先调用该方法，然后对它的返回值进行JSON化。
JSON.stringify()的第二个可选参数可以是一个数组（必须是字符串数组，包含需要处理的key），也可以是一个函数，这个函数首先会对对象本身执行一次，然后对对象的每个键值执行一次，每次传递两个参数（key和value），如果要忽略某个键则返回undefined，否则返回对应的值。
<code>JSON.stringify()</code>的第三个可选参数space，指定输出的缩进格式。可以是正整数（指定每一级缩进的字符数），也可以是字符串，此时最前面的是个字符被用于每一级的缩进。</p> <p><code>ToNumber()</code>,将非数字类型转换为数字类型，true转化为1，false转化为0， undefined转化为NaN，null转为0。转化字符串时以0开头的十六进制字符串会按照十进制进行处理。对于对象，会首先检测是否有valueOf()方法，并且返回基本类型值，如果没有则使用toString()，若两者都不返回基本类型则报错。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/vuepress-blog/javascript专题/class继承与es5继承的区别.html" class="prev">
        class继承与es5继承的区别
      </a></span> <span class="next"><a href="/vuepress-blog/javascript专题/基本数据类型.html">
        基本数据类型
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/vuepress-blog/assets/js/app.ad5aaf85.js" defer></script><script src="/vuepress-blog/assets/js/2.b6e7c728.js" defer></script><script src="/vuepress-blog/assets/js/13.fe79309d.js" defer></script>
  </body>
</html>
